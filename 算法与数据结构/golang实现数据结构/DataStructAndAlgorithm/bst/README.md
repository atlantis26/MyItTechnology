树结构：本身是一种天然的组织结构，比如：文件系统目录结构、企业部门组织结构等
为什么要有树结构？

    1、高效：与线性数据结构相比，找到一个元素，不需要遍历，能够缩小检索范围
    
二叉树：

    1、概念：
        节点：二叉树节点最多只能有2个子节点，一个父节点
        根节点： 没有父节点的节点，一个树结构只有一个根节点；
        left节点：左孩子节点；
        right节点： 右孩子节点；
        叶节点：一个子节点都没有的节点；
        满二叉树： 每个节点都有左右2个子节点
        
    2、二叉树具有天然递归结构：
        每一个节点的左子树也是一个二叉树；
        每一个节点的右子树也是一个二叉树；
        二叉树节点不一定是“满”的；
        一个节点也可以是一个二叉树；
        空节点也可以是一个二叉树；

二分搜索树：Binary Select Tree
    
    1、概念：
        二分搜索树是二叉树
        二分搜索树的每一个节点的值：
            大于其左子树的所有节点的值；
            小于其右子树的所有节点的值；
        每一颗子树也是二分搜索树；
        存储的元素必须有可比较性；
        二分搜索树的元素查询，如果查询的元素比节点的值大，则该节点的左子树就不用查询了，直接在右子树中检索；
        依次递归，最终查询到目标元素；其特性大大缩减了检索的范围；
        
        上述描述的二分搜索树不包含重复元素，如果想包含重复元素的话，只需要定义：
        左子树是小于等于节点； 或者右子树大于等于节点；
        注意：之前将的数组和链表，可以有重复元素
        
    2、二分搜索树添加元素：
        1）使用递归方式实现； 
        2）非递归写法实现，和链表很像
        
    3、二分搜索树的查询遍历：
        1）深度优先遍历：
            前序遍历： 先node节点， 然后left子树，最后right子树，是最常用的遍历方式
            中序遍历： 先left子树,然后node节点，最后right子树，且遍历的结果是所有节点的排序后结果
            后续遍历： 先left子树,然后right子树，最后node节点
        
            深入理解二分搜索树的前中后序遍历：
                每个节点会被访问3次；
                前序遍历是第1次访问该节点时就对该节点做操作， 其余2次什么都不做；
                中序遍历是第2次访问该节点时就对该节点做操作， 其余2次什么都不做；
                后序遍历是第3次访问该节点时就对该节点做操作， 其余2次什么都不做；
         
         2) 广度优先遍历：
            层序遍历：一般是使用非递归方式实现的，需要借用队列来实现算法
            广度优先的意义： 更快的找到问题的解， 常用于算法设计中--最短路径； 图中的深度优先遍历和广度优先遍历
        
        3) 二分搜索树的顺序性：
            容易找到bst中的最小值、最大值，并进行删除等操作；
            容易找到一个节点的前驱节点或后继节点，并进行删除操作；
            容易实现实现找到某个节点的稍小的节点元素： 
                floor() ,floor方法与前驱节点的区别是前者可能不存在，而后者是已经存在的节点；
            容易实现实现找到某个节点的稍大的节点元素： 
                ceil()， ceil方法与后继节点相比，前者可能不存在，而后者是已经存在的节点；
            容易实现某个节点的排名的操作：rank()
            容易实现查询排名为x的节点的操作：select（）
            容易维护一个depath的值，深度值；
            支持重复元素的二分搜索树的实现；
            
           
        
        
    
    
   
   